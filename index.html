<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>åœ°ç†é™¢åœ°å›³ï¼‹ã‚³ãƒ³ãƒ‘ã‚¹è£œæ­£ï¼ˆç£æ°—ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥å¯¾å¿œï¼‰</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
  html, body, #map { height: 100%; margin: 0; padding: 0; }
  #controls {
    position: absolute; top: 10px; left: 10px; z-index: 1000;
    background: rgba(200,220,255,0.9);
    padding: 12px; border-radius: 10px;
    box-shadow: 0 0 6px rgba(0,0,0,0.3);
    font-size: 15px; transition: background 0.5s;
  }
  button {
    margin: 6px 0; width: 180px; height: 48px; font-size: 16px;
    border: none; border-radius: 10px; cursor: pointer;
    background: #007bff; color: #fff; font-weight: bold;
  }
  #resetBtn { background: #555; }
  #info { margin-top: 5px; font-weight: bold; }
</style>
</head>
<body>
<div id="controls">
  <button id="lockBtn">ğŸ¯ ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ­ãƒƒã‚¯ã‚ªãƒ³</button><br>
  <button id="resetBtn">ğŸ” è£œæ­£ãƒªã‚»ãƒƒãƒˆ</button><br>
  <div id="info">è£œæ­£è§’: 0Â°</div>
</div>
<div id="map"></div>

<script>
let map = L.map('map');
L.tileLayer('https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png', {
  attribution: 'åœ°ç†é™¢åœ°å›³', maxZoom: 18
}).addTo(map);

let currentLat = null, currentLon = null;
let currentHeading = 0, measuredHeading = null, correctionOffset = 0;
let headingLine = null, targetMarker = null;
let targetSelectMode = false;
let userMarker = L.circleMarker([0,0], {radius:6, color:'blue', fillColor:'blue', fillOpacity:0.8}).addTo(map);

// åˆæœŸä½ç½®ã‚’ç¾åœ¨åœ°ã«è¨­å®š
navigator.geolocation.getCurrentPosition(pos => {
  currentLat = pos.coords.latitude;
  currentLon = pos.coords.longitude;
  map.setView([currentLat, currentLon], 14);
  userMarker.setLatLng([currentLat, currentLon]);
}, err => {
  console.warn('ç¾åœ¨åœ°å–å¾—å¤±æ•—:', err);
  map.setView([35.6812,139.7671], 13); // fallback: æ±äº¬é§…
});

// ç¾åœ¨åœ°è¿½è·¡
navigator.geolocation.watchPosition(pos => {
  currentLat = pos.coords.latitude;
  currentLon = pos.coords.longitude;
  userMarker.setLatLng([currentLat, currentLon]);
  updateLine();
}, err => {
  console.warn('ä½ç½®æƒ…å ±å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
}, { enableHighAccuracy: true, maximumAge: 1000 });

// ã‚³ãƒ³ãƒ‘ã‚¹èª­ã¿è¾¼ã¿
if (window.DeviceOrientationEvent) {
  window.addEventListener('deviceorientationabsolute' in window ? 'deviceorientationabsolute' : 'deviceorientation', e => {
    if (e.absolute || e.webkitCompassHeading !== undefined) {
      currentHeading = e.webkitCompassHeading || 360 - e.alpha;
      updateLine();
    }
  });
}

// ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ­ãƒƒã‚¯ã‚ªãƒ³
const lockBtn = document.getElementById('lockBtn');
const controls = document.getElementById('controls');
lockBtn.onclick = () => {
  if (currentHeading == null) { alert('æ–¹ä½ã‚»ãƒ³ã‚µãƒ¼ãŒæœªå–å¾—ã§ã™'); return; }
  measuredHeading = currentHeading;
  alert(`ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ­ãƒƒã‚¯ã‚ªãƒ³ï¼ (${measuredHeading.toFixed(1)}Â°)\nåœ°å›³ä¸Šã§ç›®æ¨™ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãã ã•ã„ã€‚`);
  targetSelectMode = true;
};

// åœ°å›³ã‚¯ãƒªãƒƒã‚¯ã§è£œæ­£
map.on('click', e => {
  if (!targetSelectMode || measuredHeading == null || currentLat == null) return;
  const bearing = getBearing(currentLat, currentLon, e.latlng.lat, e.latlng.lng);
  correctionOffset = measuredHeading - bearing;
  if (correctionOffset > 180) correctionOffset -= 360;
  if (correctionOffset < -180) correctionOffset += 360;
  document.getElementById('info').innerText = `è£œæ­£è§’: ${correctionOffset.toFixed(1)}Â°`;

  // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒãƒ¼è‰²å¤‰æ›´
  controls.style.background = 'rgba(255,210,210,0.9)';

  // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒãƒ¼ã‚«ãƒ¼è¡¨ç¤º
  if (targetMarker) targetMarker.remove();
  targetMarker = L.marker([e.latlng.lat, e.latlng.lng], {title: 'ã‚¿ãƒ¼ã‚²ãƒƒãƒˆ'}).addTo(map);

  alert(`è£œæ­£è§’ã‚’è¨ˆç®—ã—ã¾ã—ãŸ: ${correctionOffset.toFixed(1)}Â°`);
  targetSelectMode = false;
  updateLine();
});

// ãƒªã‚»ãƒƒãƒˆ
const resetBtn = document.getElementById('resetBtn');
resetBtn.onclick = () => {
  correctionOffset = 0;
  measuredHeading = null;
  targetSelectMode = false;
  document.getElementById('info').innerText = 'è£œæ­£è§’: 0Â°';
  controls.style.background = 'rgba(200,220,255,0.9)';
  if (targetMarker) targetMarker.remove();
  updateLine();

  // ãƒ‰ãƒªãƒ•ãƒˆè­¦å‘Šã‚’ãƒªã‚»ãƒƒãƒˆ
  const driftEl = document.getElementById('driftAlert');
  if (driftEl) driftEl.remove();
  driftDetected = false;
};

// ç£æ°—ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥ï¼ˆå§¿å‹¢å®‰å®šä¸­ï¼‰
let lastHeading = null, lastPitch = null, lastRoll = null, lastCheck = Date.now();
let driftDetected = false;

window.addEventListener('deviceorientation', e => {
  const heading = e.webkitCompassHeading || 360 - e.alpha;
  const pitch = e.beta;
  const roll = e.gamma;

  if (lastHeading != null) {
    const dh = Math.abs(heading - lastHeading);
    const dp = Math.abs(pitch - lastPitch);
    const dr = Math.abs(roll - lastRoll);
    const dt = Date.now() - lastCheck;

    if (dt > 1000 && dp < 3 && dr < 3 && dh > 25) {
      console.warn(`[ãƒ‰ãƒªãƒ•ãƒˆæ¤œçŸ¥] dh=${dh.toFixed(1)}Â°, dp=${dp.toFixed(1)}Â°, dr=${dr.toFixed(1)}Â°`);
      showDriftAlert();
      driftDetected = true;
    }
  }

  lastHeading = heading;
  lastPitch = pitch;
  lastRoll = roll;
  lastCheck = Date.now();
});

function showDriftAlert() {
  if (document.getElementById('driftAlert')) return;
  const infoBox = document.getElementById('info');
  const alertEl = document.createElement('div');
  alertEl.id = 'driftAlert';
  alertEl.textContent = 'âš ï¸ ç£æ°—ãƒ‰ãƒªãƒ•ãƒˆç–‘ã„æ¤œçŸ¥';
  alertEl.style.color = 'red';
  alertEl.style.fontWeight = 'bold';
  alertEl.style.marginTop = '4px';
  infoBox.insertAdjacentElement('afterend', alertEl);
}

function updateLine() {
  if (currentLat == null || currentLon == null) return;
  let corrected = currentHeading - correctionOffset;
  const end = computeDestinationPoint(currentLat, currentLon, corrected, 100000);
  if (headingLine) headingLine.remove();
  const color = correctionOffset === 0 ? 'blue' : 'red';
  headingLine = L.polyline([[currentLat, currentLon], [end.lat, end.lon]], {color: color, weight:4}).addTo(map);
}

function getBearing(lat1, lon1, lat2, lon2) {
  const Ï†1 = lat1 * Math.PI / 180, Ï†2 = lat2 * Math.PI / 180;
  const Î”Î» = (lon2 - lon1) * Math.PI / 180;
  const y = Math.sin(Î”Î») * Math.cos(Ï†2);
  const x = Math.cos(Ï†1)*Math.sin(Ï†2) - Math.sin(Ï†1)*Math.cos(Ï†2)*Math.cos(Î”Î»);
  const Î¸ = Math.atan2(y, x);
  return (Î¸ * 180 / Math.PI + 360) % 360;
}

function computeDestinationPoint(lat, lon, bearing, distance) {
  const R = 6371000;
  const Î´ = distance / R;
  const Î¸ = bearing * Math.PI / 180;
  const Ï†1 = lat * Math.PI / 180;
  const Î»1 = lon * Math.PI / 180;
  const Ï†2 = Math.asin(Math.sin(Ï†1)*Math.cos(Î´) + Math.cos(Ï†1)*Math.sin(Î´)*Math.cos(Î¸));
  const Î»2 = Î»1 + Math.atan2(Math.sin(Î¸)*Math.sin(Î´)*Math.cos(Ï†1), Math.cos(Î´)-Math.sin(Ï†1)*Math.sin(Ï†2));
  return { lat: Ï†2*180/Math.PI, lon: Î»2*180/Math.PI };
}
</script>
</body>
</html>
